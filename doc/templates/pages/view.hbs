<p class="h3">Define a view</p>

<div class="code">
<pre>
tetra.view.register(name, Object)
</pre>
</div>

<p class="description">
    <b>name</b> The name of the view; this must be the same as the name of the file.
    For example: if you call your view likeButton, included file will be named “likeButton.ui.js”.
</p>
<p class="description">
    <b>Object</b> This object configures the view, and describes view module listeners and notifiers as well as DOM handlers.
</p>

<p class="subtitle">Description</p>

<div class="code">
<pre>
{  
   scope : 'scope name',  
   use : ['controller name', ...],  
   root : 'containerId',  
   constr : function   
}
</pre>
</div>

<p class="description">

<p class="description">
    <b>scope</b> a namespace for the view; it limits the scope of message sent by the view such that only controllers in the same namespace will be notified.<br>
</p>
<p class="description">
    <b>use</b> the list of controllers used by the view.<br>
</p>
<p class="description">
    <b>root</b> (optional) id of a root element for the view. It will limit selectors matching.<br>
</p>
<p class="description">
    <b>constr</b> a function returning the view's public API
</p>

<p class="subtitle">Constructor</p>

<div class="code">
<pre>
constr : function(me, app, _) { 
	return {  
     	events : {...},  
     	methods : {...}  
	};
}
</pre>
</div>

<p class="description">
    <b>me</b> similar to 'this' in OO JavaScript, this variable gives you access to all attributes of the view object itself and allows you to define your own functions and attributes<br>
</p>
<p class="description">
    <b>app</b> the communication pipe to all controllers in the scope.<br>
</p>
<p class="description">
    <b>_</b> abstracted javascript library based on the <a href="http://api.jquery.com" target="_blank">jQuery</a> API, with following available functions.
</p>

<p class="subtitle">Events</p>

<div class="code">
<pre>
events : {  
   user : {  
       'event name' : {  
            'selector' : function(event, element){...},  
            ...  
        },  
        ...  
   },  
   window : {  
        'event name' : function(event){...},  
         ...  
   },  
   controller : {  
        'message' : function(data){...},  
        ...  
   }  
}
</pre>
</div>

<p class="description">
<b>events</b> description of callbacks executed as a consequence of a controller or a user action :<br>
</p>
<p class="description">
<b>user</b> list of events listeners for the page. For each event (click, mouseover, etc.), we specify a list of selectors (CSS2.1 syntax) that respond to the event and invoke a callback. This callback has access to the native event and the matched DOM element in context. e.preventDefault() is automatically called  (except for checkbox/radio input element and keydown event). If you want to disable this behavior, add a "no-prevent" class on your element.
</p>

<p class="subtitle">Special event management:</p><br>

<p class="description">
<b>mouseover/mouseout</b> these events are normalized and automatically cleaned up. That means they work as mouseenter and mouseleave and don't react to events from the element's children.<br>
</p>
<p class="description">
<b>clickout</b> you can define a clickout listener for a specific selector. The callback will be invoked when the user clicks outside any element matching the selector. This listener only works if a click listener with the same selector is defined in the same view.
</p>

<p class="description">
<b>window</b> list of window event listeners.<br>
</p>
<p class="description">
<b>controller</b> list of callbacks that listen for messages sent by controllers. Any arguments sent with the message as passed to the callback.
</p>

<p class="subtitle">Methods</p>

<div class="code">
<pre>
methods : {  
    init : function(){...},  
    MyMethod : function(param){...},  
    ...
}
</pre>
</div>

<p class="description">
<b>init</b> is a reserved method executed when the view is registered. It can be used to define some variables accessible in the view. For example to define a DOM access, you can define a variable as an attribute attached to me : me.target = document.getElementById('targetId');<br>
Methods are common functions used locally in the view. They can be called using the me keyword.<br>
For example <b>me.methods.customMethod(data)</b> to call the function customMethod.
</p>

Sample code ...
