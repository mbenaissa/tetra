<p class="h3">Define an ORM</p>

<p class="description">
    The ORM is an abstraction layer for data access. In a web context, it abstracts out asynchronous calls. It guarantees the integrity of data and standardises how this data is used in the application. When calling the orm, you must specify which model object you wish to interact with. For example to create a likeObj instance you would write :
<p>

<div class="code">
<pre>
orm('likeObj').create({…});
</pre>
</div>

<p class="description">
    <b>orm(*).create(attributes)</b> creates an object with the list of attributes passed as a parameter. The instance is returned to enable method chaining.
</p>
<p class="description">
    <b>obj.save()</b> or <b>orm(*).save(attributes)</b> saves an instance on the server. If the validate function returns true the object is stored; otherwise we revert the save. Calling save from the orm object bypasses the object creation step and so is not recommended.
</p>
<p class="description">
    <b>obj.remove()</b> or <b>orm(*).del(ref)</b> removes an object locally and on the server if an id is specified.
</p>
<p class="description">
    <b>orm(*).reset()</b> removes all instances of this model.
</p>
<p class="description">
    <b>orm(*).length</b> returns the count of instances of this model.
</p>

<p class="description">
    <b>orm(*).find(id, successCbk)</b> finds the object with the specified id. If it isn’t available locally, we fetch the object from on server. The success callback is invoked with the object as a parameter when it is available. If not specified, callback defined in controllers will be called.
</p>
<p class="description">
    <b>orm(*).findByRef(ref, successCbk)</b> returns the object with specified reference. This is the object instance as stored locally, so no call to the server is made.
</p>
<p class="description">
    <b>orm(*).findByCond(cond, successCbk)</b> finds a collection of local instances of the classes. Again, this is the object instances as stored locally, so no call to the server is made. The success callback, when available, is called with the collection as a parameter. If not specified, callback defined in controllers will be called.
</p>
<p class="description">
    <b>orm(*).select(cond, successCbk [optional])</b> finds the collection of matching objects. If this is the first request for an object it is retrieved from the server; otherwise the local reference is returned. The success callback, when available, is called with the collection as a parameter. If not specified, callback defined in controllers will be called.
</p>
<p class="description">
    <b>orm(*).fetch(cond, successCbk [optional])</b> finds the collection of matching objects. Identical to select, except that objects are always retrieved from server. The success callback, when available, is called with the collection as a parameter. If not specified, callback defined in controllers will be called.
</p>

<p class="subtitle">Specific case: html ajax call</p>
<p class="description">
    If you want to retrieve html via an ajax call, we recommend using the global model "html" (define it as a dependency in 'use' using g/html).
</p>

<div class="code">
<pre>
tetra.model.register('html', {

  req : {
	fetch : {
	  url: '{0}',
	  uriParams: ['url'],
	  parser : function(resp, col, cond) {
		col[cond.uriParams.url] = {id: cond.uriParams.url, html: resp};
		return col;
	  }
	}
  },

  attr : {
	html : ''
  },

  methods : function(attr) {
    return {
	  validate : function(attr, errors){
	     if (attr.html == '') errors.push('html');
		 return errors;
	  }
    };
  }

});
</pre>
</div>

<p class="subtitle">ORM requesting in controller</p>

<div class="code">
<pre>
orm('html').fetch({uriParams: {url: '/path/to/page'}}).success(function(obj) {
    var markup =  obj.get('html');
});
</pre>
</div>

<p class="subtitle">ORM requests in controller</p>

<p class="description">
    This standard json format is used by the Tetra framework to normalize ajax exchanges and simplify implementation on both Back-End and Front-End sides. You can see below the global definition of this format and details of how they are handled by Tetra.
</p>

<div class="code">
<pre>
{
    "status": "SUCCESS/FAIL",
    "data": {
        4: {...},
        9: {...},
        37: {...}
    },
    "alerts": {
        "attr1": "alert message 1",
        "attr2": "alert message 2"
    },
    "errors": [
        "error message x",
        "error message y"
    ],
    "count": 3
}
</pre>
</div>

<p class="description">
    <b>status</b> : Status of the response. Could take 2 values : SUCCESS or FAIL
</p>
<p class="description">
    <b>data</b> A set of objects indexed by object id. Each object specifies the attributes of a result: {"id": 4, "firstName": "John", "lastName": "Doe", ...}
</p>
<p class="description">
    <b>alerts</b> : A set of alert messages indexed by associated attribute. Alerts usually correspond with validation errors, and are returned by responses with a status equal to FAIL but a HTTP response code of 200.
</p>
<p class="description">
    <b>errors</b> : An array of error messages. Error messages are returned when the server cannot satisfy the request; the status is FAIL but the HTTP response code is something other than 200.
</p>
<p class="description">
    <b>count</b> (optional): The total count of available results for the request.
</p>

<p class="subtitle">ORM request in controller</p>

<p class="description">
    Below, examples of typical server responses<br>
    Status 200
</p>

<div class="code">
<pre>
{
    "status": "SUCCESS",
    "data": {
        59: {"id": 59, ...}
    }
}
</pre>
</div>

<p class="subtitle">Status code 200 with some validation errors</p>

<div class="code">
<pre>
{
    "status": "FAIL",
    "data": {
        59: {"id": 59, ...}
    },
    "alerts": {
        "attr1": "alert message 1",
        "attr2": "alert message 2"
    }
}
</pre>
</div>

<p class="subtitle">Error status codes (!=200)</p>

<div class="code">
<pre>
{
    "status": "FAIL",
    "errors": [
        "error message x",
        "error message y"
    ]
}
</pre>
</div>